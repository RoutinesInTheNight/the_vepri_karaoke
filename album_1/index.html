<!doctype html>
<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Karaoke timing player</title>
    <style>
        @font-face {
            font-family: 'Sf Pro Display Regular';
            src: url('fonts/SFPRODISPLAYREGULAR.OTF') format('truetype')
        }

        @font-face {
            font-family: 'Sf Pro Display Medium';
            src: url('fonts/SFPRODISPLAYMEDIUM.OTF') format('truetype')
        }

        @font-face {
            font-family: 'Sf Pro Display Bold';
            src: url('fonts/SFPRODISPLAYBOLD.OTF') format('truetype')
        }

        :root {
            --bg: #0f1115;
            --muted: #8b8b8b;
            --accent: #ffffff;

            --body-width: 100vw;
            --vw: calc(var(--body-width) / 100);
        }

        * {
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            text-decoration: none;
        }

        /* html,
        body {
            height: 100%;
            margin: 0;
            background: linear-gradient(180deg, #081018 0%, #0f1720 100%);
            font-family: 'Sf Pro Display Regular', Arial, sans-serif;
        } */

        html,
        body {
            height: 100%;
            /* background-color: black; */
            background: linear-gradient(180deg, #081018 0%, #0f1720 100%);
            color: white;
            font-family: 'Sf Pro Display Bold', Arial, sans-serif;
            overflow-x: hidden;
            margin: 0 auto;
            padding: 0;
        }

        .app {
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: stretch
        }

        /* Lyrics area */
        .lyrics-wrap {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden
        }

        .lines {
            width: 100%;
            max-width: 90%;
            display: block;
            position: relative;
            /* padding: 0 20px */
        }

        .lines-list {
            list-style: none;
            padding: 0;
            margin: 0;
            position: relative;
            transition: transform 1000ms cubic-bezier(.2, .9, .3, 1)
        }

        .lines-list li {
            /* height: 48px; */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            /* line-height: 1.3; */
            /* padding: 0 10px; */
            font-size: calc(100 / 428 * 24 * 1vw);
            margin: calc(100 / 428 * 32 * 1vw) 0 calc(100 / 428 * 32 * 1vw) 0;
            /* color: var(--muted); */
            opacity: 0.25;
            transition: transform .5s, opacity .5s
        }

        .lines-list li.active {
            opacity: 1;
            /* font-size: calc(100 / 428 * 24 * 1vw); */
            /* font-family: 'Sf Pro Display Bold', Arial, sans-serif; */
        }

        /* before play: offset first line slightly down */
        .not-playing .lines-list {
            transform: translateY(30px)
        }




        /* Controls */
        .controls {
            padding: 18px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-top: 1px solid rgba(255, 255, 255, 0.03);
            display: flex;
            flex-direction: column;
            gap: 12px
        }

        .timeline-row {
            display: flex;
            align-items: center;
            gap: 12px
        }

        .time-left,
        .time-right {
            width: 60px;
            text-align: center;
            font-variant-numeric: tabular-nums;
            color: var(--muted);
            font-size: 14px
        }

        .timeline {
            flex: 1;
            height: 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.04);
            position: relative;
            cursor: pointer
        }

        .progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            border-radius: 8px;
            background: linear-gradient(90deg, #74b47e, #2fb66b)
        }

        .btn-row {
            display: flex;
            align-items: center;
            justify-content: center
        }

        .play-btn {
            width: 64px;
            height: 64px;
            border-radius: 999px;
            background: linear-gradient(180deg, #294c34, #1b2f23);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.05)
        }

        .play-btn svg {
            width: 28px;
            height: 28px;
            fill: #fff
        }

        /* small screens tweaks */
        /* @media (max-width:520px) {
            .lines-list li {
                font-size: 18px;
                height: 44px
            }

            .time-left,
            .time-right {
                width: 48px;
                font-size: 12px
            }
        } */
    </style>
</head>

<body>
    <div class="app not-playing" id="app">

        <div class="lyrics-wrap">
            <div class="lines">
                <ul class="lines-list" id="lines"></ul>
            </div>
        </div>

        <div class="controls">
            <div class="timeline-row">
                <div class="time-left" id="current">0:00</div>
                <div class="timeline" id="timeline" title="Seek">
                    <div class="progress" id="progress"></div>
                </div>
                <div class="time-right" id="duration">0:00</div>
            </div>

            <div class="btn-row">
                <div class="play-btn" id="playBtn" aria-pressed="false" role="button">
                    <!-- play icon (will toggle) -->
                    <svg viewBox="0 0 24 24" id="playIcon">
                        <path d="M8 5v14l11-7z"></path>
                    </svg>
                </div>
            </div>
        </div>

        <!-- Hidden audio element (song.mp3 must be next to index) -->
        <audio id="audio" preload="metadata" src="song.mp3"></audio>
    </div>

    <script>
        // --- Demo SRT-like cues (you will later load a real .srt file) ---
        const cues = [
            { start: 0.0, end: 1.0, text: "" },
            { start: 1.0, end: 2.0, text: "Сетевой нигилист, неутихающий гонор" },
            { start: 2.0, end: 3.0, text: "Вторая строчка идёт следом за первой" },
            { start: 3.0, end: 4.0, text: "Третья строчка, по центру она появится" },
            { start: 4.0, end: 5.0, text: "Четвёртая строчка, немного позже" },
            { start: 5.0, end: 6.0, text: "Пятая строчка — пример длинной фразы, она может переноситься" },
            { start: 6.0, end: 7.0, text: "Ещё одна строка для теста" },
            { start: 7.0, end: 8.0, text: "Финальная строка, пауза и конец" }
        ];

        // --- DOM ---
        const audio = document.getElementById('audio');
        const playBtn = document.getElementById('playBtn');
        const playIcon = document.getElementById('playIcon');
        const currentEl = document.getElementById('current');
        const durationEl = document.getElementById('duration');
        const progress = document.getElementById('progress');
        const timeline = document.getElementById('timeline');
        const linesList = document.getElementById('lines');
        const app = document.getElementById('app');

        // Build list
        cues.forEach((c, i) => {
            const li = document.createElement('li');
            li.textContent = c.text;
            li.dataset.index = i;
            linesList.appendChild(li);
        });

        let activeIndex = 0;
        let isPlaying = false;

        function formatTime(t) {
            if (!isFinite(t)) return '0:00';
            const m = Math.floor(t / 60);
            const s = Math.floor(t % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        // once metadata loaded, set duration
        audio.addEventListener('loadedmetadata', () => {
            durationEl.textContent = formatTime(audio.duration);
        });

        // Play/pause toggle
        playBtn.addEventListener('click', () => {
            if (audio.paused) {
                audio.play();
            } else {
                audio.pause();
            }
        });

        // reflect play/pause
        audio.addEventListener('play', () => {
            isPlaying = true;
            playIcon.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>'; // pause
            app.classList.remove('not-playing');
        });
        audio.addEventListener('pause', () => {
            isPlaying = false;
            playIcon.innerHTML = '<path d="M8 5v14l11-7z"></path>'; // play
            if (audio.currentTime === 0) app.classList.add('not-playing');
        });

        // Update time and progress and lyrics
        audio.addEventListener('timeupdate', () => {
            const t = audio.currentTime;
            currentEl.textContent = formatTime(t);
            const pct = (t / audio.duration) * 100;
            progress.style.width = Math.max(0, Math.min(100, pct)) + '%';

            // find active cue
            let idx = cues.findIndex(c => t >= c.start && t < c.end);
            if (idx === -1) {
                // if after last cue, set to last
                if (t >= cues[cues.length - 1].end) idx = cues.length - 1;
                else if (t < cues[0].start) idx = 0;
            }
            if (idx !== activeIndex) {
                setActive(idx);
            }
        });

        // click to seek
        timeline.addEventListener('click', (e) => {
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const pct = x / rect.width;
            if (audio.duration) audio.currentTime = pct * audio.duration;
        });

        // make keyboard space toggle
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); if (audio.paused) audio.play(); else audio.pause(); } });

        function setActive(idx) {
            if (idx == null || idx < 0) idx = 0;
            idx = Math.min(cues.length - 1, idx);
            activeIndex = idx;
            // highlight
            document.querySelectorAll('#lines li').forEach(li => li.classList.remove('active'));
            const activeLi = document.querySelector(`#lines li[data-index='${idx}']`);
            if (activeLi) activeLi.classList.add('active');

            // compute translate to center the active li
            const liHeight = activeLi ? activeLi.offsetHeight : 48;
            const listRect = linesList.getBoundingClientRect();
            const wrapRect = linesList.parentElement.getBoundingClientRect();
            const centerY = wrapRect.height / 2;
            // index top offset
            let offset = 0;
            const activeTop = activeLi ? activeLi.offsetTop : 0;
            // want activeTop + liHeight/2 to align with centerY
            offset = centerY - (activeTop + liHeight / 2);
            linesList.style.transform = `translateY(${offset}px)`;
        }

        // Initialize: before play, make first line slightly below center (handled by .not-playing class)
        setActive(0);

        // click on a line to seek to its start
        linesList.addEventListener('click', (e) => {
            const li = e.target.closest('li');
            if (!li) return;
            const i = Number(li.dataset.index);
            if (cues[i]) {
                audio.currentTime = cues[i].start + 0.001; // tiny offset to ensure timeupdate registers
                if (audio.paused) audio.play();
            }
        });

        // For accessibility: announce which line is active (simple console for demo)
        audio.addEventListener('ended', () => {
            playIcon.innerHTML = '<path d="M8 5v14l11-7z"></path>';
            app.classList.add('not-playing');
        });

        // Optional: if you want to programmatically load SRT later, here's a tiny parser you can reuse
        function parseSRT(srtText) {
            // returns array of {start, end, text}
            const blocks = srtText.trim().split(/\n\n+/);
            const out = [];
            blocks.forEach(b => {
                const lines = b.split(/\n/).map(l => l.trim()).filter(Boolean);
                if (lines.length >= 2) {
                    // first is index or cue number, second is timing
                    const timing = lines.find(l => l.match(/\d{2}:\d{2}:\d{2},\d{3}/));
                    if (!timing && lines[1]) {
                        // sometimes index present
                        const tline = lines[1];
                        const m = tline.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s * (\d{ 2}: \d{ 2}: \d{ 2}, \d{ 3}) /);
            if (m) {
                out.push({ start: toSeconds(m[1]), end: toSeconds(m[2]), text: lines.slice(2).join(' ') });
            }
        } else {
            const m = lines[0].match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
            if (m) { out.push({ start: toSeconds(m[1]), end: toSeconds(m[2]), text: lines.slice(1).join(' ') }); }
        }
        }
      });
        return out;

        function toSeconds(t) {
            const p = t.split(/[:,]/).map(Number);
            return p[0] * 3600 + p[1] * 60 + p[2] + (p[3] || 0) / 1000;
        }
    }

    </script>
</body>

</html>